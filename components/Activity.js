/**
 * Êú¨Êñá‰ª∂Áî®Âà∞ÁöÑ‰∏ªË¶ÅÂáΩÊï∞ÂíåÈí©Â≠êËØ¥ÊòéÔºàË°•ÂÖ®ÁâàÔºâÔºö
 *
 * „ÄêReactÈí©Â≠ê„Äë
 * useState, useEffect, useContext, useRef, useMemo, useCallback ‚Äî‚Äî Áî®‰∫éÁä∂ÊÄÅÁÆ°ÁêÜ„ÄÅÁîüÂëΩÂë®Êúü„ÄÅÂâØ‰ΩúÁî®„ÄÅÂºïÁî®„ÄÅËÆ∞ÂøÜÂåñÁ≠â„ÄÇ
 * useTranslation ‚Äî‚Äî ÂõΩÈôÖÂåñÁøªËØëÈí©Â≠ê„ÄÇ
 * useIsFocused ‚Äî‚Äî Âà§Êñ≠È°µÈù¢ÊòØÂê¶ËÅöÁÑ¶ÁöÑÂØºËà™Èí©Â≠ê„ÄÇ
 *
 * „ÄêËá™ÂÆö‰πâÊ†°È™åÂáΩÊï∞„Äë
 * isValidAmount ‚Äî‚Äî Ê†°È™åÈáëÈ¢ùÊúâÊïàÊÄß„ÄÇ
 * isValidState ‚Äî‚Äî Ê†°È™åÁä∂ÊÄÅÊúâÊïàÊÄß„ÄÇ
 *
 * „Äê‰∫§ÊòìÂéÜÂè≤Áõ∏ÂÖ≥ÂºÇÊ≠•ÂáΩÊï∞„Äë
 * fetchAllActivityLog ‚Äî‚Äî Ëé∑ÂèñÊâÄÊúâ‰∫§ÊòìÂéÜÂè≤„ÄÇ
 * fetchNextActivityLogPage ‚Äî‚Äî ÂàÜÈ°µËé∑Âèñ‰∫§ÊòìÂéÜÂè≤„ÄÇ
 * fetchTransactionFee ‚Äî‚Äî Ëé∑ÂèñÈìæ‰∏äÊâãÁª≠Ë¥π„ÄÇ
 *
 * „ÄêÊåâÈíÆÁÇπÂáªÂ§ÑÁêÜÂáΩÊï∞„Äë
 * handleSendPress ‚Äî‚Äî Â§ÑÁêÜÂèëÈÄÅÊåâÈíÆÁÇπÂáª„ÄÇ
 * handleReceivePress ‚Äî‚Äî Â§ÑÁêÜÊé•Êî∂ÊåâÈíÆÁÇπÂáª„ÄÇ
 * handleConvertPress ‚Äî‚Äî Â§ÑÁêÜÂÖëÊç¢ÊåâÈíÆÁÇπÂáª„ÄÇ
 *
 * „ÄêËÆæÂ§áÁÆ°ÁêÜÁõ∏ÂÖ≥ÂáΩÊï∞„Äë
 * handleDevicePress ‚Äî‚Äî ËÆæÂ§áÁÇπÂáªÂ§ÑÁêÜ„ÄÇ
 * handleDisconnectDevice ‚Äî‚Äî Êñ≠ÂºÄËÆæÂ§áËøûÊé•„ÄÇ
 * reconnectDevice ‚Äî‚Äî ËÆæÂ§áÈáçËøû„ÄÇ
 *
 * „ÄêPINÁ†ÅÂ§ÑÁêÜÂáΩÊï∞„Äë
 * handlePinSubmit ‚Äî‚Äî PINÁ†ÅÊèê‰∫§Â§ÑÁêÜ„ÄÇ
 * handlePinSubmitProxy ‚Äî‚Äî PINÁ†ÅÊèê‰∫§‰ª£ÁêÜ„ÄÇ
 *
 * „ÄêÂú∞ÂùÄÈ™åËØÅÁõ∏ÂÖ≥„Äë
 * handleVerifyAddress ‚Äî‚Äî Âú∞ÂùÄÈ™åËØÅÂ§ÑÁêÜ„ÄÇ
 *
 * „ÄêÂä†ÂØÜË¥ßÂ∏ÅÈÄâÊã©Áõ∏ÂÖ≥„Äë
 * selectCrypto ‚Äî‚Äî ÈÄâÊã©Âä†ÂØÜË¥ßÂ∏ÅÂ§ÑÁêÜ„ÄÇ
 *
 * „ÄêÊ≠•È™§ÂàáÊç¢Â§ÑÁêÜÂáΩÊï∞„Äë
 * handleNextAfterAddress ‚Äî‚Äî Âú∞ÂùÄËæìÂÖ•Âêé‰∏ã‰∏ÄÊ≠•Â§ÑÁêÜ„ÄÇ
 * handleNextAfterAmount ‚Äî‚Äî ÈáëÈ¢ùËæìÂÖ•Âêé‰∏ã‰∏ÄÊ≠•Â§ÑÁêÜ„ÄÇ
 *
 * „ÄêÂú∞ÂùÄËæìÂÖ•Â§ÑÁêÜ„Äë
 * handleAddressChange ‚Äî‚Äî Âú∞ÂùÄËæìÂÖ•ÂèòÊõ¥Â§ÑÁêÜ„ÄÇ
 *
 * „ÄêÁõëÂê¨Áõ∏ÂÖ≥ÂáΩÊï∞„Äë
 * monitorVerificationCode ‚Äî‚Äî ÁõëÂê¨È™åËØÅÁ†Å„ÄÇ
 * monitorSignedResult ‚Äî‚Äî ÁõëÂê¨Á≠æÂêçÁªìÊûú„ÄÇ
 * stopMonitoringVerificationCode ‚Äî‚Äî ÂÅúÊ≠¢ÁõëÂê¨È™åËØÅÁ†Å„ÄÇ
 * stopMonitoringTransactionResponse ‚Äî‚Äî ÂÅúÊ≠¢ÁõëÂê¨‰∫§ÊòìÂèçÈ¶à„ÄÇ
 *
 * „ÄêÂ∑•ÂÖ∑ÂáΩÊï∞„Äë
 * signTransaction ‚Äî‚Äî ‰∫§ÊòìÁ≠æÂêçÂ§ÑÁêÜ„ÄÇ
 * Clipboard, Buffer, AsyncStorage, fetch ‚Äî‚Äî Ââ™Ë¥¥Êùø„ÄÅ‰∫åËøõÂà∂„ÄÅÂ≠òÂÇ®„ÄÅÁΩëÁªúËØ∑Ê±ÇÁ≠âÂ∑•ÂÖ∑„ÄÇ
 * detectNetwork ‚Äî‚Äî Ê£ÄÊµãÂú∞ÂùÄÁΩëÁªúÁ±ªÂûã„ÄÇ
 * scanDevices ‚Äî‚Äî Êâ´ÊèèËìùÁâôËÆæÂ§á„ÄÇ
 * displayDeviceAddress ‚Äî‚Äî ÊòæÁ§∫ËÆæÂ§áÂú∞ÂùÄ„ÄÇ
 * createHandlePinSubmit, createHandleDevicePress, createMonitorVerificationCode ‚Äî‚Äî Â∑•ÂéÇÂáΩÊï∞ÁîüÊàêÂ§ÑÁêÜÂô®„ÄÇ
 *
 * „Äê‰∫ã‰ª∂Â§ÑÁêÜÂáΩÊï∞„Äë
 * onPress, onRequestClose, onConfirm, onCancel, onRefresh, onLoadMore, onChangeText ‚Äî‚Äî ‰º†ÈÄíÁªôÁªÑ‰ª∂ÂíåModalÁöÑ‰∫ã‰ª∂Â§ÑÁêÜ„ÄÇ
 *
 * „ÄêÂÖ∂‰ªñËá™ÂÆö‰πâÂáΩÊï∞„Äë
 * cleanActivityLog ‚Äî‚Äî Ê∏ÖÁêÜ‰∫§ÊòìÂéÜÂè≤Êó•Âøó„ÄÇ
 * onRefresh ‚Äî‚Äî Âà∑Êñ∞‰∫§ÊòìÂéÜÂè≤„ÄÇ
 * reconnectDevice ‚Äî‚Äî ËÆæÂ§áÈáçËøû„ÄÇ
 *
 * Â¶ÇÈúÄ‰∫ÜËß£ÂÖ∑‰ΩìÂÆûÁé∞ÔºåËØ∑Êü•ÈòÖÂØπÂ∫îÂáΩÊï∞ÂÆö‰πâÂíåË∞ÉÁî®Â§Ñ„ÄÇ
 */

import React, { useContext, useState, useRef, useEffect } from "react";
import { View, Platform, AppState } from "react-native";
import Clipboard from "@react-native-clipboard/clipboard";
import { LinearGradient } from "expo-linear-gradient";
import { Buffer } from "buffer";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Constants from "expo-constants";
import { useTranslation } from "react-i18next";
import { BleManager } from "react-native-ble-plx";
import { useIsFocused } from "@react-navigation/native";

// ÈÖçÁΩÆ‰∏éÂ∑•ÂÖ∑
import { prefixToShortName } from "../config/chainPrefixes";
import assetOps from "../config/assetOps";
import { detectNetwork } from "../config/networkUtils";
import checkAndReqPermission from "../utils/BluetoothPermissions";
import { chainGroups, families } from "../config/mappingRegistry";

// ‰∏ä‰∏ãÊñáÂíåÊ†∑Âºè
import { DeviceContext, DarkModeContext } from "../utils/DeviceContext";
import ActivityScreenStyles from "../styles/ActivityScreenStyle";

// Modal ÁªÑ‰ª∂
import TransactionConfirmationModal from "./modal/TransactionConfirmationModal";
import ContactFormModal from "./modal/ContactFormModal";
import ActivityProgressModal from "./modal/ActivityProgressModal";
import CheckStatusModal from "./modal/CheckStatusModal";
import BluetoothModal from "./modal/BluetoothModal";
import AmountModal from "./modal/AmountModal";
import SelectAssetModal from "./modal/SelectAssetModal";
import ConvertModal from "./modal/ConvertModal";
import ReceiveAddressModal from "./modal/ReceiveAddressModal";
import SecurityCodeModal from "./modal/SecurityCodeModal";
import ActivityLogComponent from "./ActivityScreen/ActivityLogComponent";
import ActionButtons from "./ActivityScreen/ActionButtons";
// Ëá™ÂÆö‰πâÁªÑ‰ª∂
import displayDeviceAddress from "../utils/displayDeviceAddress";
import { parseDeviceCode } from "../utils/parseDeviceCode";
import { createHandlePinSubmit } from "../utils/handlePinSubmit";
import { accountAPI, signAPI } from "../env/apiEndpoints";
import signTransaction from "./ActivityScreen/signTransaction";
import { bluetoothConfig } from "../env/bluetoothConfig";
import { createHandleDevicePress } from "../utils/handleDevicePress";
// ÂÖ¨ÂÖ±Â∑•ÂéÇÂáΩÊï∞
import createMonitorVerificationCode from "../utils/monitorVerificationCode";
import { scanDevices } from "../utils/scanDevices";
import {
  fetchAllActivityLog,
  fetchNextActivityLogPage,
} from "../utils/activityLog";
import { fetchTransactionFee } from "../utils/fetchTransactionFee";
import { handleDisconnectDevice } from "../utils/handleDisconnectDevice";
import { handleVerifyAddress } from "../utils/handleVerifyAddress";
import createSelectCrypto from "../utils/selectCrypto";
const FILE_NAME = "Activity.js";
// BLE Â∏∏Èáè
const serviceUUID = bluetoothConfig.serviceUUID;
const writeCharacteristicUUID = bluetoothConfig.writeCharacteristicUUID;
const notifyCharacteristicUUID = bluetoothConfig.notifyCharacteristicUUID;

function ActivityScreen() {
  const [CheckStatusModalVisible, setCheckStatusModalVisible] = useState(false);
  // Â∑•ÂÖ∑ÂáΩÊï∞„ÄÅÊ∏ÖÁêÜÂáΩÊï∞ÊîæËøôÈáå
  function isValidAmount(amount) {
    if (amount === null || amount === undefined) return false;
    if (amount === "0" || amount === "" || amount === "null") return false;
    if (Number(amount) === 0 || isNaN(Number(amount))) return false;
    return true;
  }
  function isValidState(state) {
    if (state === 0 || state === "0" || state === null || state === undefined) {
      return false;
    }
    return true;
  }
  async function cleanActivityLog(logs) {
    const filtered = logs.filter(
      (item) => isValidAmount(item.amount) && isValidState(item.state)
    );
    await AsyncStorage.setItem("ActivityLog", JSON.stringify(filtered));
    setActivityLog(filtered);
  }

  // ---------- Áä∂ÊÄÅÂíå‰∏ä‰∏ãÊñá ----------
  const { t } = useTranslation();

  const {
    updateCryptoAddress,
    initialAdditionalCryptos,
    exchangeRates,
    currencyUnit,
    addedCryptos,
    setAddedCryptos,
    isVerificationSuccessful,
    setIsVerificationSuccessful,
    verifiedDevices,
    setVerifiedDevices,
    cryptoCards,
    setCryptoCards,
    ActivityLog,
    setActivityLog,
    updateDevicePubHintKey,
  } = useContext(DeviceContext);
  const isFocused = useIsFocused(); // üîπÂà§Êñ≠ÊòØÂê¶ÂΩìÂâçÈ°µÈù¢
  const appState = useRef(AppState.currentState); // üîπ‰øùÂ≠òÂΩìÂâç App Áä∂ÊÄÅ
  const [isLoading, setIsLoading] = useState(true);
  const { isDarkMode } = useContext(DarkModeContext);
  const ActivityScreenStyle = ActivityScreenStyles(isDarkMode);
  const iconColor = isDarkMode ? "#CCB68C" : "#CFAB95";
  const darkColors = ["#21201E", "#0E0D0D"];
  const lightColors = ["#FFFFFF", "#EDEBEF"];
  const buttonBackgroundColor = isDarkMode ? "#CCB68C" : "#CFAB95";
  const disabledButtonBackgroundColor = isDarkMode ? "#6c6c6c" : "#ccc";
  const [missingChainsForModal, setMissingChainsForModal] = useState([]);
  // ‰∫§Êòì/ËÆæÂ§á/ÁïåÈù¢Áä∂ÊÄÅ
  const [receivedVerificationCode, setReceivedVerificationCode] = useState("");
  const [swapModalVisible, setConvertModalVisible] = useState(false);
  const [
    confirmingTransactionModalVisible,
    setConfirmingTransactionModalVisible,
  ] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [addressModalVisible, setAddressModalVisible] = useState(false);
  const [operationType, setOperationType] = useState("");
  const restoreIdentifier = Constants.installationId;
  const [selectedAddress, setSelectedAddress] = useState("");
  const [balance, setBalance] = useState("");
  const [EstimatedValue, setEstimatedValue] = useState("");
  const [selectedCryptoName, setSelectedCryptoName] = useState("");
  const [selectedCrypto, setSelectedCrypto] = useState("");
  const [selectedCryptoIcon, setSelectedCryptoIcon] = useState(null);
  const [selectedQueryChainName, setQueryChainName] = useState("");
  const [priceUsd, setPriceUsd] = useState("");
  const [amount, setAmount] = useState("");
  const [inputAddress, setInputAddress] = useState("");
  const [chainShortName, setChainShortName] = useState("");
  const [amountModalVisible, setAmountModalVisible] = useState(false);
  const [confirmModalVisible, setConfirmModalVisible] = useState(false);
  const [hasFetchedBalance, setHasFetchedBalance] = useState(false);
  const [selectedDevice, setSelectedDevice] = useState(null);
  const [bleVisible, setBleVisible] = useState(false);
  const [isScanning, setIsScanning] = useState(false);
  const [devices, setDevices] = useState([]);
  const [SecurityCodeModalVisible, setSecurityCodeModalVisible] =
    useState(false);
  const [pinCode, setPinCode] = useState("");
  const [verificationStatus, setVerificationStatus] = useState(null);
  const [isAddressValid, setIsAddressValid] = useState(false);
  const [isVerifyingAddress, setIsVerifyingAddress] = useState(false);
  const [receivedAddresses, setReceivedAddresses] = useState({});
  const [ContactFormModalVisible, setContactFormModalVisible] = useState(false);
  const [detectedNetwork, setDetectedNetwork] = useState("");
  const [fee, setFee] = useState("");
  const [rapidFee, setRapidFee] = useState("");
  const [fromDropdownVisible, setFromDropdownVisible] = useState(false);
  const [toDropdownVisible, setToDropdownVisible] = useState(false);
  const [addressVerificationMessage, setAddressVerificationMessage] = useState(
    t("Verifying address on your device...")
  );
  const [pageData, setPageData] = useState([]);
  const [hasMore, setHasMore] = useState(true);
  const [activityLogPages, setActivityLogPages] = useState({});
  const [selectedFromToken, setSelectedFromToken] = useState("");
  const [selectedToToken, setSelectedToToken] = useState("");
  const [selectedFeeTab, setSelectedFeeTab] = useState("Recommended");
  const [modalStatus, setModalStatus] = useState({
    title: t("Waiting for approval on your device...."),
    subtitle: t("Waiting for approval on your device..."),
    image: require("../assets/gif/Pending.gif"),
  });

  // Ë¥πÁî®ËÆ°ÁÆó
  const feeValue = isNaN(parseFloat(fee)) ? 0 : parseFloat(fee);
  const rapidFeeVal = isNaN(parseFloat(rapidFee)) ? 0 : parseFloat(rapidFee);
  //  console.log("parseFloat(fee) ÁöÑÂÄºÊòØ:", feeValue);
  // console.log("parseFloat(rapidFee) ÁöÑÂÄºÊòØ:", rapidFeeVal);
  // Áõ¥Êé•ÊòæÁ§∫‰∏ªÂ∏ÅÂçï‰ΩçÔºå‰∏çÂÜçÈô§‰ª•1e9
  const recommendedFee = fee; // Â∑≤ÁªèÊòØ‰∏ªÂ∏ÅÂçï‰ΩçÂ≠óÁ¨¶‰∏≤
  const recommendedValue = (
    feeValue *
    priceUsd *
    exchangeRates[currencyUnit]
  ).toFixed(2);
  const rapidFeeValue = rapidFee; // Â∑≤ÁªèÊòØ‰∏ªÂ∏ÅÂçï‰ΩçÂ≠óÁ¨¶‰∏≤
  const rapidCurrencyValue = (
    rapidFeeVal *
    priceUsd *
    exchangeRates[currencyUnit]
  ).toFixed(2);
  const isAmountValid =
    amount &&
    parseFloat(amount) > 0 &&
    parseFloat(amount) <= parseFloat(balance) + feeValue;
  const [refreshing, setRefreshing] = useState(false);

  const onRefresh = async () => {
    setRefreshing(true);
    await fetchAllActivityLog({
      initialAdditionalCryptos,
      setActivityLog,
      setActivityLogPages,
      accountAPI,
    });
    setRefreshing(false);
  };

  // ---------- Êâ´ÊèèËÆæÂ§á ----------
  const { bleManagerRef } = useContext(DeviceContext);

  // Clear values when opening the modal
  useEffect(() => {
    if (swapModalVisible) {
      setSelectedFromToken("");
      setSelectedToToken("");
    }
  }, [swapModalVisible]);

  useEffect(() => {
    const loadActivityLog = async () => {
      setIsLoading(true);
      try {
        const historyJson = await AsyncStorage.getItem("ActivityLog");
        if (historyJson !== null) {
          const history = JSON.parse(historyJson);
          setActivityLog(history);
        }
      } catch (error) {
        console.error(
          "Failed to load transaction history from storage:",
          error
        );
      }
      setIsLoading(false);
    };

    loadActivityLog();
  }, []);

  // Êñ∞Â¢ûÔºöËé∑ÂèñÊâÄÊúâÂç°ÁâáÁöÑ‰∫§ÊòìÂéÜÂè≤ËÆ∞ÂΩïÔºàÂåÖÂê´ÂéªÈáç‰∏éÂàÜÈ°µÂ§ÑÁêÜÔºâ

  // ‚è±Ô∏è ÊØè 30 ÁßíÂÆöÊó∂Âà∑Êñ∞Ôºå‰ªÖÂΩìÂâçÈ°µÈù¢‰∏î App ÂâçÂè∞ÊâçÊâßË°å
  useEffect(() => {
    const intervalId = setInterval(() => {
      if (appState.current === "active" && isFocused) {
        fetchAllActivityLog({
          initialAdditionalCryptos,
          setActivityLog,
          setActivityLogPages,
          accountAPI,
        });
      }
    }, 30000);

    const handleAppStateChange = (nextAppState) => {
      appState.current = nextAppState;
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      clearInterval(intervalId);
      subscription.remove(); // ‚úÖ Ê≠£Á°ÆÁßªÈô§ÁõëÂê¨Âô®
    };
  }, [isFocused, initialAdditionalCryptos]);

  // Âú® ActivityScreen ÁªÑ‰ª∂ÁöÑ useEffect ÊàñÂêàÈÄÇ‰ΩçÁΩÆÊ∑ªÂä†‰ª£Á†ÅÊù•Ëé∑ÂèñÊâãÁª≠Ë¥π

  useEffect(() => {
    if (amountModalVisible) {
      fetchTransactionFee({
        selectedQueryChainName,
        setFee,
        setRapidFee,
        accountAPI,
      });
    }
  }, [amountModalVisible]);

  // Êü•ËØ¢Êï∞Â≠óË¥ßÂ∏Å‰ΩôÈ¢ù Êü•ËØ¢‰ΩôÈ¢ù
  useEffect(() => {
    if (amountModalVisible && !hasFetchedBalance) {
      const fetchWalletBalance = async () => {
        try {
          // ÊâæÂà∞ÈÄâ‰∏≠ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂØπË±°
          const selectedCryptoObj = initialAdditionalCryptos.find(
            (crypto) => crypto.shortName === selectedCrypto
          );

          if (!selectedCryptoObj) {
            console.log("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂØπË±°");
            return;
          }

          // Âæ™ÁéØÈÅçÂéÜ cryptoCardsÔºå‰∏∫ÈÄâÊã©ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÊü•ËØ¢‰ΩôÈ¢ù
          for (let card of cryptoCards) {
            // Âè™Êü•ËØ¢ÂåπÈÖçÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂíåÈìæ
            if (
              card.queryChainShortName?.toLowerCase() ===
                selectedCryptoObj.queryChainShortName?.toLowerCase() &&
              card.queryChainName?.toLowerCase() ===
                selectedQueryChainName?.toLowerCase()
            ) {
              console.log("Êù°‰ª∂Êª°Ë∂≥ÔºåÂáÜÂ§áÂèëÈÄÅËØ∑Ê±Ç...");

              const postData = {
                chain: card.queryChainName,
                address: card.address,
              };

              // ÊâìÂç∞ÂèëÈÄÅÁöÑ POST Êï∞ÊçÆ
              console.log("ÂèëÈÄÅÁöÑ POST Êï∞ÊçÆ:", postData);

              const response = await fetch(accountAPI.balance, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(postData),
              });
              const data = await response.json();

              // ÊâìÂç∞Êî∂Âà∞ÁöÑÂìçÂ∫îÊï∞ÊçÆ
              console.log("Êî∂Âà∞ÁöÑÂìçÂ∫îÊï∞ÊçÆ:", data);

              if (data.code === "0" && data.data) {
                const { name, balance } = data.data;

                // ÊâìÂç∞ÂìçÂ∫îÊï∞ÊçÆ‰∏≠ÁöÑÂêçÁß∞Âíå‰ΩôÈ¢ù
                console.log(`ÂìçÂ∫îÊï∞ÊçÆ‰∏≠ÁöÑÂêçÁß∞: ${name}, ‰ΩôÈ¢ù: ${balance}`);

                // Êõ¥Êñ∞ÈÄâÊã©ÁöÑÂä†ÂØÜË¥ßÂ∏Å‰ΩôÈ¢ù
                if (name.toLowerCase() === card.queryChainName.toLowerCase()) {
                  card.balance = balance;

                  setCryptoCards((prevCards) => {
                    AsyncStorage.setItem(
                      "cryptoCards",
                      JSON.stringify(prevCards)
                    );
                    return prevCards.map((prevCard) =>
                      prevCard.queryChainName.toLowerCase() ===
                      card.queryChainName.toLowerCase()
                        ? { ...prevCard, balance: balance }
                        : prevCard
                    );
                  });
                }
              } else {
                console.log("ÂìçÂ∫îÊï∞ÊçÆÊó†ÊïàÊàñÈîôËØØ‰ª£Á†Å:", data.code);
              }
              break; // Âè™Êü•ËØ¢ÂåπÈÖçÁöÑÂç°ÁâáÔºåÊü•ËØ¢ÂÆåÊØïÂêéË∑≥Âá∫Âæ™ÁéØ
            } else {
              console.log(
                `Âç°ÁâáÂêçÁß∞ÂíåÈìæÂêçÁß∞‰∏çÂåπÈÖçÔºåË∑≥ËøáÊü•ËØ¢: ${card.name} - ${card.queryChainName}`
              );
            }
          }
        } catch (error) {
          console.log("Êü•ËØ¢‰ΩôÈ¢ùÊó∂ÂèëÁîüÈîôËØØ:", error);
        }
      };

      fetchWalletBalance();
      setHasFetchedBalance(true); // Ê†áËÆ∞‰∏∫Â∑≤Êü•ËØ¢‰ΩôÈ¢ùÔºåÈò≤Ê≠¢ÈáçÂ§çÊü•ËØ¢
    }
  }, [
    amountModalVisible, // Á°Æ‰øùÂú® amountModalVisible ÂèòÂåñÊó∂Ëß¶ÂèëÊü•ËØ¢
    hasFetchedBalance, // Á°Æ‰øù‰ΩôÈ¢ùÂè™Êü•ËØ¢‰∏ÄÊ¨°
    cryptoCards, // ÁõëÂê¨ cryptoCards ÂèòÂåñ
    selectedCrypto, // ÊØèÊ¨°ÈÄâÊã©ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂèòÂåñÊó∂ÈáçÊñ∞Êü•ËØ¢‰ΩôÈ¢ù
    selectedQueryChainName, // ÊØèÊ¨°ÈÄâÊã©ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÈìæÂèòÂåñÊó∂ÈáçÊñ∞Êü•ËØ¢‰ΩôÈ¢ù
    setCryptoCards,
  ]);

  // ÁõëÂê¨ initialAdditionalCryptos ÁöÑÂèòÂåñÔºåÊõ¥Êñ∞ Modal ‰∏≠ÁöÑÊï∞ÊçÆ
  useEffect(() => {
    if (amountModalVisible) {
      // Êü•ÊâæÈÄâ‰∏≠ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂØπË±°
      const selected = cryptoCards.find(
        (crypto) =>
          crypto.queryChainName.toLowerCase() ===
            selectedQueryChainName.toLowerCase() &&
          crypto.queryChainShortName.toLowerCase() ===
            selectedCrypto.toLowerCase()
      );

      // ÊâìÂç∞ÊâæÂà∞ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂØπË±°
      if (selected) {
        console.log("debugÊâæÂà∞ÂåπÈÖçÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂØπË±°:", selected);

        // ËÆæÁΩÆ‰ΩôÈ¢ù„ÄÅ‰ª∑Ê†ºÁ≠â
        setBalance(selected.balance);
        setPriceUsd(selected.priceUsd);
        setEstimatedValue(selected.EstimatedValue);
        setFee(selected.fee);

        // ÊâìÂç∞ËÆæÁΩÆÁöÑÂÄº
        console.log("Â∑≤ËÆæÁΩÆ‰ª•‰∏ãÂÄº:");
        console.log("Balance:", selected.balance);
        console.log("Price in USD:", selected.priceUsd);
        console.log("Estimated value (US$):", selected.EstimatedValue);
        console.log("Processing Fee:", selected.fee);
      } else {
        console.log(
          " ÁõëÂê¨ initialAdditionalCryptos ÁöÑÂèòÂåñÊú™ÊâæÂà∞ÂåπÈÖçÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂØπË±°"
        );
      }
    }
  }, [initialAdditionalCryptos, amountModalVisible]);

  useEffect(() => {
    return () => {
      bleManagerRef.current && bleManagerRef.current.destroy();
    };
  }, []);

  useEffect(() => {
    let addressMonitorSubscription;
    const startMonitoring = async () => {
      if (addressModalVisible && selectedDevice) {
        addressMonitorSubscription = await displayDeviceAddress(selectedDevice);
      }
    };

    startMonitoring();

    // Ê∏ÖÁêÜÂáΩÊï∞ÔºåÂÖ≥Èó≠Ê®°ÊÄÅÊ°ÜÊó∂ÂÅúÊ≠¢ÁõëÂê¨
    return () => {
      if (addressMonitorSubscription) {
        addressMonitorSubscription.remove();
        console.log("ÊòæÁ§∫Âú∞ÂùÄÁõëÂê¨Â∑≤ÂÅúÊ≠¢");
      }
    };
  }, [addressModalVisible, selectedDevice]);

  // ÁõëÂê¨ËÆæÂ§áÊï∞Èáè
  useEffect(() => {
    const loadVerifiedDevices = async () => {
      try {
        // ‰ªé AsyncStorage Âä†ËΩΩÂ∑≤È™åËØÅÁöÑËÆæÂ§áÂàóË°®
        const savedDevices = await AsyncStorage.getItem("verifiedDevices");
        if (savedDevices !== null) {
          setVerifiedDevices(JSON.parse(savedDevices));
        }
      } catch (error) {
        console.log("Error loading verified devices: ", error);
      }
    };

    loadVerifiedDevices();
  }, []); // Ëøô‰∏™‰æùËµñÁ©∫Êï∞ÁªÑÁ°Æ‰øùËØ•‰ª£Á†ÅÂè™Âú®ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÊâßË°å‰∏ÄÊ¨°

  // ÂÅúÊ≠¢ÁõëÂê¨
  useEffect(() => {
    if (!SecurityCodeModalVisible) {
      stopMonitoringVerificationCode();
    }
  }, [SecurityCodeModalVisible]);

  // ‰ΩøÁî® useEffect ÁõëÂê¨Ê®°ÊÄÅÁ™óÂè£ÁöÑÂèòÂåñ
  useEffect(() => {
    if (!confirmingTransactionModalVisible) {
      stopMonitoringTransactionResponse();
    }
  }, [confirmingTransactionModalVisible]);

  useEffect(() => {
    if (!bleVisible && selectedDevice) {
      setSecurityCodeModalVisible(true);
    }
  }, [bleVisible, selectedDevice]);

  // Update Bluetooth modal visibility management
  // Â∑≤ÁßªÈô§ËìùÁâô onStateChange ÁõëÂê¨ÔºåÁªü‰∏ÄÁî± App.js ÁÆ°ÁêÜ
  useEffect(() => {
    // ‰ªé AsyncStorage Âä†ËΩΩ addedCryptos Êï∞ÊçÆ
    const loadAddedCryptos = async () => {
      try {
        const savedCryptos = await AsyncStorage.getItem("addedCryptos");
        if (savedCryptos !== null) {
          setAddedCryptos(JSON.parse(savedCryptos));
        }
      } catch (error) {
        console.log("Error loading addedCryptos: ", error);
      }
    };
    loadAddedCryptos();
  }, []);

  const reconnectDevice = async (device) => {
    try {
      console.log(`Ê≠£Âú®Â∞ùËØïÈáçÊñ∞ËøûÊé•ËÆæÂ§á: ${device.id}`);
      await device.cancelConnection(); // È¶ñÂÖàÊñ≠ÂºÄËøûÊé•
      await device.connect(); // Â∞ùËØïÈáçÊñ∞ËøûÊé•
      await device.discoverAllServicesAndCharacteristics(); // ÈáçÊñ∞ÂèëÁé∞ÊúçÂä°ÂíåÁâπÊÄß
      console.log("ËÆæÂ§áÈáçÊñ∞ËøûÊé•ÊàêÂäü");
    } catch (error) {
      console.log("ËÆæÂ§áÈáçÊñ∞ËøûÊé•Â§±Ë¥•:", error);
    }
  };

  // verificationStatus Áî®‰∫éË°®Á§∫Êï¥‰ΩìÁä∂ÊÄÅ
  // ‰æãÂ¶ÇÔºösetVerificationStatus("waiting") Êàñ setVerificationStatus("success")

  const monitorSubscription = useRef(null);

  const monitorVerificationCode = createMonitorVerificationCode({
    serviceUUID,
    notifyCharacteristicUUID,
    prefixToShortName,
    updateCryptoAddress,
    setReceivedAddresses,
    setVerificationStatus,
    updateDevicePubHintKey,
    parseDeviceCode,
    setReceivedVerificationCode,
    Buffer,
    writeCharacteristicUUID,
  });
  //ÁõëÂê¨Á≠æÂêçÁªìÊûú
  const monitorSignedResult = (device) => {
    monitorSubscription.current = device.monitorCharacteristicForService(
      serviceUUID,
      notifyCharacteristicUUID,
      async (error, characteristic) => {
        // ---- ÈîôËØØÂ§ÑÁêÜÂÆåÊï¥Â±ïÂºÄ ----
        if (error) {
          if (
            error.message &&
            error.message.includes("Operation was cancelled")
          ) {
            console.log("ÁõëÂê¨Êìç‰ΩúË¢´ÂèñÊ∂àÔºåÊ≠£Âú®ÈáçÊñ∞ËøûÊé•...");
            reconnectDevice(device); // ‰∏ªÂä®ÈáçËøûÈÄªËæë
          } else if (
            error.message &&
            error.message.includes("Unknown error occurred")
          ) {
            console.log("Êú™Áü•ÈîôËØØÔºåÂèØËÉΩÊòØ‰∏Ä‰∏™Bug:", error.message);
            if (error.reason) {
              console.log("ÈîôËØØÂéüÂõ†:", error.reason);
            }
            reconnectDevice(device); // ‰∏ªÂä®ÈáçËøûÈÄªËæë
          } else {
            console.log("ÁõëÂê¨ËÆæÂ§áÂìçÂ∫îÊó∂Âá∫Èîô:", error.message);
          }
          return; // Âá∫Áé∞ÈîôËØØÊó∂ÁªàÊ≠¢Êú¨Ê¨°ÂõûË∞É
        }

        // ---- BLE Êï∞ÊçÆËß£Á†Å ----
        const receivedData = Buffer.from(
          characteristic.value,
          "base64"
        ).toString("utf8");
        console.log("Êé•Êî∂Âà∞ÁöÑÊï∞ÊçÆ:", receivedData);
        // ---- Â§ÑÁêÜ PIN Ê†°È™åÂëΩ‰ª§ ----
        if (receivedData === "PIN_SIGN_READY") {
          setModalStatus({
            title: t("Waiting for approval on your device...."),
            subtitle: t("Waiting for approval on your device..."),
            image: require("../assets/gif/Pending.gif"),
          });
          // ÁªßÁª≠ÂêéÁª≠Á≠æÂêçÊµÅÁ®ãÔºàÂ¶ÇËØ∑Ê±ÇÈìæÂèÇÊï∞„ÄÅÂèëÈÄÅ presign Á≠âÔºâ
          proceedToNextStep && proceedToNextStep();
        } else if (receivedData === "PIN_SIGN_FAIL") {
          setModalStatus({
            title: t("Password Incorrect"),
            subtitle: t(
              "The PIN code you entered is incorrect. Transaction has been terminated."
            ),
            image: require("../assets/gif/Fail.gif"),
          });
          // ‰∏çËá™Âä®ÂÖ≥Èó≠ÔºåÁ≠âÂæÖÁî®Êà∑ÊâãÂä®ÂÖ≥Èó≠Modal
        } else if (receivedData === "PIN_SIGN_CANCEL") {
          setModalStatus({
            title: t("Password Cancelled"),
            subtitle: t(
              "Password entry cancelled by user. Transaction has been terminated."
            ),
            image: require("../assets/gif/Fail.gif"),
          });
          // ‰∏çËá™Âä®ÂÖ≥Èó≠ÔºåÁ≠âÂæÖÁî®Êà∑ÊâãÂä®ÂÖ≥Èó≠Modal
        } else if (receivedData.startsWith("signResult:")) {
          // ---- Â§ÑÁêÜÁ≠æÂêçÊï∞ÊçÆÂÆåÊï¥ÊµÅÁ®ã ----
          // ÊèêÂèñ signed_data ÂÜÖÂÆπ
          const signedData = receivedData.split("signResult:")[1];
          const [chain, hex] = signedData.split(",");
          // ÊûÑÈÄ†ÂπøÊí≠‰∫§ÊòìÁöÑÊï∞ÊçÆ
          const postData = {
            chain: chain.trim(), // ÂéªÊéâÂèØËÉΩÁöÑÁ©∫Ê†º
            hex: hex.trim(), // Âú®Á≠æÂêçÂâçÂä†‰∏ä 0xÔºåÂπ∂ÂéªÊéâÁ©∫Ê†º
            address: selectedAddress,
          };
          // ÊâìÂç∞ÂØπË±°
          console.log("ÂáÜÂ§áÂèëÈÄÅÁöÑ POST Êï∞ÊçÆ:", postData);
          // ËæìÂá∫: ÂáÜÂ§áÂèëÈÄÅÁöÑ POST Êï∞ÊçÆ: { chain: "ethereum", hex: "F86C..." }

          // Ë∞ÉÁî®ÂπøÊí≠‰∫§ÊòìÁöÑ API
          try {
            const response = await fetch(accountAPI.broadcastHex, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(postData),
            });

            const responseData = await response.json();
            // Ê†πÊçÆËøîÂõûÁöÑ code Â≠óÊÆµÂà§Êñ≠ÂπøÊí≠ÊòØÂê¶ÊàêÂäü
            if (response.ok && responseData.code === "0") {
              console.log("‰∫§ÊòìÂπøÊí≠ÊàêÂäü:", responseData);
              // ÂêëÂµåÂÖ•ÂºèËøîÂõû BCAST_OK
              try {
                const msg = Buffer.from("BCAST_OK\r\n", "utf-8").toString(
                  "base64"
                );
                await device.writeCharacteristicWithResponseForService(
                  serviceUUID,
                  writeCharacteristicUUID,
                  msg
                );
                console.log("Â∑≤ÂêëÂµåÂÖ•ÂºèÂèëÈÄÅ BCAST_OK");
              } catch (err) {
                console.log("ÂèëÈÄÅ BCAST_OK Êó∂Âá∫Èîô:", err);
              }
              setModalStatus({
                title: t("Transaction Successful"),
                subtitle: t(
                  "Your transaction was successfully broadcasted on the LUKKEY device."
                ),
                image: require("../assets/gif/Success.gif"),
              });
            } else {
              console.log("‰∫§ÊòìÂπøÊí≠Â§±Ë¥•:", responseData);
              // ÂêëÂµåÂÖ•ÂºèËøîÂõû BCAST_FAIL
              try {
                const msg = Buffer.from("BCAST_FAIL\r\n", "utf-8").toString(
                  "base64"
                );
                await device.writeCharacteristicWithResponseForService(
                  serviceUUID,
                  writeCharacteristicUUID,
                  msg
                );
                console.log("Â∑≤ÂêëÂµåÂÖ•ÂºèÂèëÈÄÅ BCAST_FAIL");
              } catch (err) {
                console.log("ÂèëÈÄÅ BCAST_FAIL Êó∂Âá∫Èîô:", err);
              }
              setModalStatus({
                title: t("Transaction Failed"),
                subtitle: t(
                  "The transaction broadcast failed. Please check your device and try again."
                ),
                image: require("../assets/gif/Fail.gif"),
              });
            }
          } catch (broadcastError) {
            console.log("‰∫§ÊòìÂπøÊí≠Êó∂Âá∫Èîô:", broadcastError.message);
            // ÂêëÂµåÂÖ•ÂºèËøîÂõû BCAST_FAIL
            try {
              const msg = Buffer.from("BCAST_FAIL\r\n", "utf-8").toString(
                "base64"
              );
              await device.writeCharacteristicWithResponseForService(
                serviceUUID,
                writeCharacteristicUUID,
                msg
              );
              console.log("Â∑≤ÂêëÂµåÂÖ•ÂºèÂèëÈÄÅ BCAST_FAIL");
            } catch (err) {
              console.log("ÂèëÈÄÅ BCAST_FAIL Êó∂Âá∫Èîô:", err);
            }
            setModalStatus({
              title: t("Transaction Error"),
              subtitle: t(
                "An error occurred while broadcasting the transaction."
              ),
              image: require("../assets/gif/Fail.gif"),
            });
          }
        } else {
          // ---- Êú™Áü•Êï∞ÊçÆÂÆåÊï¥ÊâìÂç∞ ----
          console.log("Á≠æÂêçÁªìÊûúÊî∂Âà∞Êú™Áü•Êï∞ÊçÆ:", receivedData);
        }
      }
    );
  };

  // ÂÅúÊ≠¢ÁõëÂê¨È™åËØÅÁ†Å;
  const stopMonitoringVerificationCode = () => {
    if (monitorSubscription.current) {
      try {
        monitorSubscription.current.remove();
        monitorSubscription.current = null;
        console.log("È™åËØÅÁ†ÅÁõëÂê¨Â∑≤ÂÅúÊ≠¢");
      } catch (error) {
        console.log("ÂÅúÊ≠¢ÁõëÂê¨Êó∂ÂèëÁîüÈîôËØØ:", error);
      }
    }
  };

  let transactionMonitorSubscription;
  // ÂÅúÊ≠¢ÁõëÂê¨‰∫§ÊòìÂèçÈ¶à
  const stopMonitoringTransactionResponse = () => {
    if (transactionMonitorSubscription) {
      transactionMonitorSubscription.remove();
      transactionMonitorSubscription = null;
      console.log("‰∫§ÊòìÂèçÈ¶àÁõëÂê¨Â∑≤ÂÅúÊ≠¢");
    }
  };

  const handleConvertPress = () => {
    setConvertModalVisible(true);
  };

  // Êñ∞Â¢ûÔºö‰ΩøÁî®Â∑•ÂéÇÂáΩÊï∞ÁîüÊàê handleDevicePress
  const handleDevicePress = createHandleDevicePress({
    setReceivedAddresses,
    setVerificationStatus,
    setSelectedDevice,
    setBleVisible,
    monitorVerificationCode,
    setSecurityCodeModalVisible,
    serviceUUID,
    writeCharacteristicUUID,
    Buffer,
  });

  // handlePinSubmit Â∑≤ËøÅÁßªËá≥ utils/handlePinSubmit.js
  const handlePinSubmit = React.useMemo(
    () =>
      createHandlePinSubmit({
        setSecurityCodeModalVisible,
        setCheckStatusModalVisible,
        setVerificationStatus,
        setVerifiedDevices,
        setIsVerificationSuccessful,
        setPinCode,
        setReceivedAddresses,
        prefixToShortName,
        monitorVerificationCode,
        serviceUUID,
        writeCharacteristicUUID,
      }),
    [
      setSecurityCodeModalVisible,
      setCheckStatusModalVisible,
      setVerificationStatus,
      setVerifiedDevices,
      setIsVerificationSuccessful,
      setPinCode,
      setReceivedAddresses,
      prefixToShortName,
      monitorVerificationCode,
      serviceUUID,
      writeCharacteristicUUID,
    ]
  );

  // ÂåÖË£Ö‰∏ÄÂ±ÇÔºåÊî∂ÈõÜ‰æùËµñÂèÇÊï∞ÔºåÈÄÇÈÖç SecurityCodeModal ÁöÑÊó†ÂèÇ onSubmit
  const handlePinSubmitProxy = React.useCallback(() => {
    handlePinSubmit({
      receivedVerificationCode,
      pinCode,
      selectedDevice,
      receivedAddresses,
    });
  }, [
    handlePinSubmit,
    receivedVerificationCode,
    pinCode,
    selectedDevice,
    receivedAddresses,
  ]);

  const handleReceivePress = () => {
    scanDevices({ isScanning, setIsScanning, bleManagerRef, setDevices });
    setOperationType("receive");
    setModalVisible(true);
  };

  const handleSendPress = () => {
    scanDevices({ isScanning, setIsScanning, bleManagerRef, setDevices });
    setOperationType("Send");
    setIsAddressValid(false);
    setModalVisible(true);
  };

  const selectCrypto = React.useCallback(
    createSelectCrypto({
      setSelectedCrypto,
      setSelectedAddress,
      setSelectedCryptoIcon,
      setBalance,
      setEstimatedValue,
      setFee,
      setPriceUsd,
      setQueryChainName,
      setChainShortName,
      setSelectedCryptoName,
      setIsVerifyingAddress,
      setModalVisible,
      setAddressModalVisible,
      setInputAddress,
      setContactFormModalVisible,
      setBleVisible,
      operationType,
      verifiedDevices,
      devices,
    }),
    [
      setSelectedCrypto,
      setSelectedAddress,
      setSelectedCryptoIcon,
      setBalance,
      setEstimatedValue,
      setFee,
      setPriceUsd,
      setQueryChainName,
      setChainShortName,
      setSelectedCryptoName,
      setIsVerifyingAddress,
      setModalVisible,
      setAddressModalVisible,
      setInputAddress,
      setContactFormModalVisible,
      setBleVisible,
      operationType,
      verifiedDevices,
      devices,
    ]
  );

  const handleNextAfterAddress = () => {
    setAmount("");
    setContactFormModalVisible(false);
    setAmountModalVisible(true);
  };

  const handleNextAfterAmount = () => {
    setAmountModalVisible(false);
    setConfirmModalVisible(true);
  };

  const handleAddressChange = (text) => {
    setInputAddress(text);
    const network = detectNetwork(text);
    setDetectedNetwork(network);
    setIsAddressValid(network !== "Invalid address"); // Update address validity
  };

  return (
    <LinearGradient
      colors={isDarkMode ? darkColors : lightColors}
      style={ActivityScreenStyle.bgContainer}
    >
      <View className="w-[100%]" style={ActivityScreenStyle.container}>
        <ActionButtons
          ActivityScreenStyle={ActivityScreenStyle}
          t={t}
          iconColor={iconColor}
          handleSendPress={handleSendPress}
          handleReceivePress={handleReceivePress}
          handleConvertPress={handleConvertPress}
        />
        {/* ‰∫§ÊòìÂéÜÂè≤ËÆ∞ÂΩïÁªÑ‰ª∂ */}
        <ActivityLogComponent
          ActivityScreenStyle={ActivityScreenStyle}
          t={t}
          ActivityLog={ActivityLog}
          isLoading={isLoading}
          cryptoCards={cryptoCards}
          refreshing={refreshing}
          onRefresh={onRefresh}
          onLoadMore={async () => {
            await fetchNextActivityLogPage({
              initialAdditionalCryptos,
              activityLogPages,
              ActivityLog,
              setActivityLog,
              setActivityLogPages,
              accountAPI,
            });
          }}
          hasMore={hasMore}
        />
        {/* ËæìÂÖ•Âú∞ÂùÄÁöÑ Modal */}
        <ContactFormModal
          visible={ContactFormModalVisible}
          onRequestClose={() => setContactFormModalVisible(false)}
          ActivityScreenStyle={ActivityScreenStyle}
          t={t}
          isDarkMode={isDarkMode}
          handleAddressChange={handleAddressChange}
          inputAddress={inputAddress}
          detectedNetwork={detectedNetwork}
          isAddressValid={isAddressValid}
          buttonBackgroundColor={buttonBackgroundColor}
          disabledButtonBackgroundColor={disabledButtonBackgroundColor}
          handleNextAfterAddress={handleNextAfterAddress}
          setContactFormModalVisible={setContactFormModalVisible}
          selectedCrypto={selectedCrypto}
          selectedCryptoChain={selectedQueryChainName}
          selectedCryptoIcon={selectedCryptoIcon}
        />
        {/* ËæìÂÖ•ÈáëÈ¢ùÁöÑ Modal */}
        <AmountModal
          visible={amountModalVisible}
          onRequestClose={() => setAmountModalVisible(false)}
          ActivityScreenStyle={ActivityScreenStyle}
          t={t}
          isDarkMode={isDarkMode}
          amount={amount}
          setAmount={setAmount}
          balance={balance}
          fee={fee}
          rapidFee={rapidFee}
          setFee={setFee}
          isAmountValid={isAmountValid}
          buttonBackgroundColor={buttonBackgroundColor}
          disabledButtonBackgroundColor={disabledButtonBackgroundColor}
          handleNextAfterAmount={handleNextAfterAmount}
          selectedCrypto={selectedCrypto}
          selectedCryptoChain={selectedQueryChainName}
          selectedCryptoIcon={selectedCryptoIcon}
          currencyUnit={currencyUnit}
          exchangeRates={exchangeRates}
          cryptoCards={cryptoCards}
          selectedCryptoName={selectedCryptoName}
          EstimatedValue={EstimatedValue}
          setCryptoCards={setCryptoCards}
          recommendedFee={recommendedFee}
          recommendedValue={recommendedValue}
          rapidFeeValue={rapidFeeValue}
          rapidCurrencyValue={rapidCurrencyValue}
          selectedFeeTab={selectedFeeTab}
          setSelectedFeeTab={setSelectedFeeTab}
        />
        {/* ‰∫§ÊòìÁ°ÆËÆ§ÁöÑ Modal */}
        <TransactionConfirmationModal
          visible={confirmModalVisible}
          onRequestClose={() => setConfirmModalVisible(false)}
          onConfirm={async () => {
            try {
              if (!chainShortName)
                throw new Error("Êú™ÈÄâÊã©ÈìæÊàñÊú™ËÆæÁΩÆ chainShortName");
              if (verifiedDevices.length === 0) throw new Error("Êú™È™åËØÅËÆæÂ§á");

              const device = devices.find((d) => d.id === verifiedDevices[0]);
              if (!device) throw new Error("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑËÆæÂ§á");

              const selectedCryptoObj = initialAdditionalCryptos.find(
                (crypto) => crypto.shortName === selectedCrypto
              );
              if (!selectedCryptoObj) {
                throw new Error(`Êú™ÊâæÂà∞Âä†ÂØÜË¥ßÂ∏ÅÔºö${selectedCrypto}`);
              }

              setConfirmModalVisible(false);
              // ÂÖàÊòæÁ§∫‚ÄúËØ∑Âú®ËÆæÂ§á‰∏äËæìÂÖ•ÂØÜÁ†Å‚ÄùÁöÑÁä∂ÊÄÅ
              setModalStatus({
                title: t("Please enter password on your device"),
                subtitle: t("Please enter password on your device"),
                image: require("../assets/gif/Enter.gif"),
              });
              setConfirmingTransactionModalVisible(true);

              // 2ÁßíÂêéÂàáÊç¢Âà∞‚Äúwaiting for approval on your device...‚ÄùÁä∂ÊÄÅÂπ∂ÂêØÂä®Á≠æÂêç
              setTimeout(async () => {
                setModalStatus({
                  title: t("Waiting for approval on your device...."),
                  subtitle: t("Waiting for approval on your device..."),
                  image: require("../assets/gif/Pending.gif"),
                });
                await signTransaction(
                  device,
                  amount,
                  selectedCryptoObj.address,
                  inputAddress,
                  selectedCryptoObj.queryChainName,
                  selectedCryptoObj.contractAddress,
                  selectedFeeTab,
                  recommendedFee,
                  rapidFeeValue,
                  setModalStatus,
                  t,
                  monitorSignedResult,
                  monitorSubscription
                );
              }, 2000); // Á≠â2ÁßíËøõÂÖ•Á≠æÂêçÊ≠•È™§Ëøô‰∏ÄÊ≠•Êú¨ÊÑèÊòØËÆ©Áî®Êà∑Âú®ÂµåÂÖ•Âºè‰∏äÈù¢ËæìÂÖ•ÂØÜÁ†Å
            } catch (error) {
              console.log("Á°ÆËÆ§‰∫§ÊòìÊó∂Âá∫Èîô:", error);
            }
          }}
          onCancel={() => setConfirmModalVisible(false)}
          t={t}
          ActivityScreenStyle={ActivityScreenStyle}
          isDarkMode={isDarkMode}
          selectedCryptoIcon={selectedCryptoIcon}
          selectedCrypto={selectedCrypto}
          selectedCryptoChain={selectedQueryChainName}
          amount={amount}
          priceUsd={priceUsd}
          exchangeRates={exchangeRates}
          currencyUnit={currencyUnit}
          recommendedFee={recommendedFee}
          recommendedValue={recommendedValue}
          rapidFeeValue={rapidFeeValue}
          rapidCurrencyValue={rapidCurrencyValue}
          selectedFeeTab={selectedFeeTab}
          setSelectedFeeTab={setSelectedFeeTab}
          detectedNetwork={detectedNetwork}
          selectedAddress={selectedAddress}
          inputAddress={inputAddress}
        />
        {/* ÈÄâÊã©Êé•Êî∂ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÊ®°ÊÄÅÁ™óÂè£ */}
        <SelectAssetModal
          visible={modalVisible}
          onRequestClose={() => setModalVisible(false)}
          addedCryptos={addedCryptos}
          operationType={operationType}
          selectCrypto={selectCrypto}
          ActivityScreenStyle={ActivityScreenStyle}
          t={t}
          setModalVisible={setModalVisible}
          isDarkMode={isDarkMode}
        />
        {/* ÊòæÁ§∫ÈÄâÊã©ÁöÑÂä†ÂØÜË¥ßÂ∏ÅÂú∞ÂùÄÁöÑÊ®°ÊÄÅÁ™óÂè£ */}
        <ReceiveAddressModal
          visible={addressModalVisible}
          onClose={() => setAddressModalVisible(false)}
          styleObj={ActivityScreenStyle}
          cryptoIcon={selectedCryptoIcon}
          cryptoName={selectedCrypto}
          address={selectedAddress}
          isVerifying={isVerifyingAddress}
          verifyMsg={addressVerificationMessage}
          handleVerify={(chainShortName) =>
            handleVerifyAddress({
              chainShortName,
              verifiedDevices,
              devices,
              setAddressModalVisible,
              setBleVisible,
              displayDeviceAddress,
              setIsVerifyingAddress,
              setAddressVerificationMessage,
              t,
            })
          }
          isDarkMode={isDarkMode}
          chainShortName={chainShortName}
        />
        {/* Bluetooth Modal */}
        <BluetoothModal
          visible={bleVisible}
          devices={devices}
          isScanning={isScanning}
          iconColor={iconColor}
          handleDevicePress={handleDevicePress}
          onCancel={() => {
            setBleVisible(false);
            setSelectedDevice(null);
          }}
          verifiedDevices={"0"}
          SecureDeviceScreenStyle={ActivityScreenStyle}
          t={t}
          onDisconnectPress={async (device) => {
            await handleDisconnectDevice({
              device,
              verifiedDevices,
              setVerifiedDevices,
              setIsVerificationSuccessful,
            });
          }}
        />
        {/* PIN Modal */}
        <SecurityCodeModal
          visible={SecurityCodeModalVisible}
          pinCode={pinCode}
          setPinCode={setPinCode}
          onSubmit={handlePinSubmitProxy}
          onCancel={() => {
            setSecurityCodeModalVisible(false);
            setPinCode("");
          }}
          styles={ActivityScreenStyle}
          isDarkMode={isDarkMode}
          t={t}
          status={verificationStatus}
        />
        {/* Verification Modal */}
        <CheckStatusModal
          visible={CheckStatusModalVisible && verificationStatus !== null}
          status={verificationStatus}
          missingChains={missingChainsForModal}
          onClose={() => setCheckStatusModalVisible(false)}
          progress={
            verificationStatus === "waiting"
              ? Object.keys(receivedAddresses).length /
                Object.keys(prefixToShortName).length
              : undefined
          }
        />
        {/* Pending Transaction Modal */}
        <ActivityProgressModal
          visible={confirmingTransactionModalVisible}
          onClose={() => setConfirmingTransactionModalVisible(false)}
          modalStatus={modalStatus}
          ActivityScreenStyle={ActivityScreenStyle}
          t={t}
        />
        {/* Convert Modal */}
        <ConvertModal
          visible={swapModalVisible}
          setConvertModalVisible={setConvertModalVisible}
          fromDropdownVisible={fromDropdownVisible}
          setFromDropdownVisible={setFromDropdownVisible}
          toDropdownVisible={toDropdownVisible}
          setToDropdownVisible={setToDropdownVisible}
          initialAdditionalCryptos={initialAdditionalCryptos}
          selectedDevice={selectedDevice}
        />
      </View>
    </LinearGradient>
  );
}

export default ActivityScreen;
